# Background
- It's really hard to reason about how complex software behaves.
- We can analyze logs generated by all apps, but you can only see info exposed by engineers who built the apps; you might need to decompile the program and look at execution flow to get more info.
- Logs give explicit data; metrics aggregate data to measure how program behaves at a specific point in time.
- Observability is the ability to ask arbitrary questions and receive complex answers from any given question. Obviously to answer any arbitrary question, we need to collect all of the data our system can generate and aggregate it only when necessary.
- Observability helps us mitigate Black Swan events since we cannot avoid them.

- Linux containers are an abstraction on top of mainly namespace & cgroup features on the Linux kernel, which are used to isolate/manage computer processes.
- Namespaces isolate tasks from one another; cgroups provide resource management (e.g., CPU, disk I/O, network etc.)

- The kernel is an evented system. BPF is a subsystem that can inspect these events.
- BPF lets you write programs that can be executed when the kernel triggers any event.

# Architecture
- BPF is an advanced VM that runs code instructions in an isolated env, similar to the Java Virtual Machine which runs machine code compiled from a high-level programming language
- Compilers (LLVM, GCC) let you compile C code into BPF instructions
- After your code is compiled, BPF uses a verifier to ensure the program is safe to run by the kernel - it prevents you from running code that might crash the kernel
- If your code is safe, the BPF prgoram will be loaded in the kernel.
- The linux kernel alsos uses a JIT compiler for BPF instructions. The JIT will transform BPF bytecode into machine code after the program is verified, avoiding this overhead on execution time.
- THis means you DON'T need to restart your system to load BPF programs; you can load them on demand and/or write your own init scripts that load BPF programs when your system starts.
- Before the kernel runs any BPF program, it needs to know which execution point the program is attached to.
- There are multiple attachment ponits in the kernel, which are defined by the BPF program types
- When you choose an execution point, the kernel also gives you specific function helpers
- BPF maps lets you share data between the kernel and user-space. They are bidirectional structures to share data, i.e., you can read/wrtite them from both sides
